% --- OFDM_SIMULATION_SCRIPT.M (Executable Code Block) ---

clear; 

%% 1. SYSTEM PARAMETERS AND CHANNEL INPUTS
M          = 16;                   % QAM order
Nfft       = 64+1;                 % OFDM size (Carriers, must be odd)
Ncp        = 16;                   % CP length
Nsym       = 100;                  % Number of OFDM symbols
fs         = 20e6;                 % Sampling frequency (Hz)
pilot_sym  = (1+1j)/sqrt(2);       % Base Pilot Symbol P (Constant Phase for LMMSE)
dead_band_length = 4;

Es         = 1;                    % Average Energy per symbol (for R_NN scaling)
SNR_dB     = 20;                   % Test SNR in dB
tau_rms    = 10e-9;                % RMS Delay Spread (100 ns) - For R_HH construction
fD         = 1;                    % Max Doppler Spread (5 Hz) - For channel model

% --- ADAPTIVE CODEBOOK PARAMETERS (TESTING SCENARIO) ---
Npt        = 4;                    % Pilot transmission time period (transmit every 4th symbol)
Npf        = 4;                    % Pilot transmission freq period (transmit every 4th symbol)
Ncirc_permute = 0;

% Sweep Params
Npt_vals = [2, 4, 8, 16];
Npf_vals = [1, 2, 4, 8];

tau_vals = [10e-9, 50e-9, 100e-9, 200e-9];
fD_vals = [1, 10, 50, 100];

%% Monte Carlo
Ntrials = 100;

AVG_SER = 0; AVG_BER = 0; AVG_Goodput = 0;
AVG_H_ERROR = 0;
AVG_H_MAG = 0;

% Subcarriers
dead_carriers = [1:dead_band_length, ceil(Nfft/2), dead_upper:(Nfft-dead_band_length)];
pilot_carriers = generate_pilots(dead_lower+1, dead_upper-1, Npf); 
all_carriers = 1:Nfft;
live_carriers = array_set_difference(all_carriers, dead_carriers);


for n = 1:Ntrials

    % 3. TRANSMITTER (TX)
    [tx, Xt, Xf, X_data_mask, X_pilot_mask] = build_OFDM_tx(Nfft, Nsym, Ncp, M, pilot_carriers, dead_carriers, pilot_sym, Npt, Ncirc_permute)
    % 4. CHANNEL MODEL
    rx_serial = apply_fading_channel(tx, fs, fD, tau_rms, SNR_dB, 1);
    % 5. RECEIVER CORE (RX Core)
    Yf = build_OFDM_rx_core(rx_serial, Nfft, Ncp, Nsym);
    % 6. EQUALIZATION (LMMSE)
    [Y_eq, Hf_est] = equalize_ofdm_data(Yf, X_data_mask, X_pilot_mask, Nfft, pilot_carriers, dead_carriers, live_carriers, pilot_sym, Ncirc_permute);
    [Hf_true] = genie_channel(Yf, Xf, live_carriers);
    % 7. DEMODULATION AND SER CALCULATION
    [SER, BER, Goodput_bps, H_error, H_mag] = calculate_performance_metrics(Y_eq, Xf, X_data_mask, Hf_true, Hf_est, tx, M, Nfft, Ncp);

    AVG_SER = AVG_SER + SER;
    AVG_BER = AVG_BER + BER;
    AVG_Goodput = AVG_Goodput + Goodput_bps;
    AVG_H_ERROR = AVG_H_ERROR + H_error;
    AVG_H_MAG = AVG_H_MAG + H_mag;
end

AVG_SER = AVG_SER / Ntrials;
AVG_BER = AVG_BER  / Ntrials;
AVG_Goodput = AVG_Goodput / Ntrials;
AVG_H_ERROR = AVG_H_ERROR / Ntrials;
AVG_H_MAG = AVG_H_MAG / Ntrials;

AVG_H_MSE = AVG_H_ERROR / AVG_H_MAG;

%% 9. FINAL RESULTS DISPLAY
disp(['Average Symbol Error Rate (SER): ', num2str(AVG_SER)]);
disp(['Average Bit Error Rate (BER):    ', num2str(AVG_BER)]);
disp(['Average Goodput (bits/sample):   ', num2str(AVG_Goodput)]);
disp(['Average H MSE:   ', num2str(AVG_H_MSE)]);
disp('--------------------------------------');


function [pilots] = generate_pilots(K, L, density)
% ... (generate_pilots function remains unchanged) ...
    
    % Calculate the total range length
    Range_Length = L - K;
    N = ceil(Range_Length / density) + 1;
    non_integer_pilots = linspace(K, L, N);
    
    center_value = (K + L) / 2;
    tolerance = 1e-9;
    is_center = abs(non_integer_pilots - center_value) < tolerance;
    non_integer_pilots(is_center) = non_integer_pilots(is_center) + 1;
    
    pilots = round(non_integer_pilots);
    pilots = unique(pilots);
    
    K_rounded = round(K);
    L_rounded = round(L);
    
    if pilots(1) ~= K_rounded
        pilots = [K_rounded, pilots];
    end
    if pilots(end) ~= L_rounded
        pilots = [pilots, L_rounded];
    end
    
    pilots = reshape(pilots, 1, []);
end

function [tx, Xt, Xf, X_data_mask, X_pilot_mask] = build_OFDM_tx(Nfft, Nsym, Ncp, M, pilot_carriers, dead_carriers, pilot_sym, Npt, Ncirc_permute)
    
    % X is now (Nfft x Nsym) -> (Carriers x Symbols)
    X = zeros(Nfft, Nsym); 
    Npilots = length(pilot_carriers);

    % --- 1. PILOT GENERATION AND INSERTION ---
    
    P_base = pilot_sym;
    P_inv = -pilot_sym; 
    
    % Temporary pilot matrix now needs to be (Npilots x Nsym)
    X_pilots = zeros(Npilots, Nsym); 
    
    % Define the pilot pattern in frequency (across columns of X_pilots)
    pilot_frequency_pattern = repmat([P_base, P_inv], 1, ceil(Npilots/2));
    pilot_frequency_pattern = pilot_frequency_pattern(1:Npilots); 
    
    % Initialize the FULL Nfft x Nsym pilot mask
    X_pilot_mask = false(Nfft, Nsym);
    
    % Loop through all OFDM symbols (columns) to construct X_pilots and X_pilot_mask
    pilot_symbol_indices = find(mod((1:Nsym) - 1, Npt) == 0);
    
    for m = pilot_symbol_indices % m is the column index (symbol index)
        % Determine pilot value
        if mod(m, 2) == 1
            X_pilots_column = pilot_frequency_pattern.'; % Transpose for column assignment
        else
            X_pilots_column = circshift(pilot_frequency_pattern, Ncirc_permute).'; % Transpose for column assignment
        end
        
        % Store the pilot values in the temporary matrix (X_pilots is Npilots x Nsym)
        X_pilots(:, m) = X_pilots_column; 
        
        % Set the corresponding locations in the pilot mask to TRUE (Rows=Carriers, Column=Symbol m)
        X_pilot_mask(pilot_carriers, m) = true;
    end
    
    % Insert the pilot matrix into X (Columns defined by pilot_carriers, all rows/symbols)
    X(pilot_carriers, :) = X_pilots;
    
    % --- 2. DATA MASK AND SYMBOL GENERATION ---
    
    % Create the DATA mask (X_data_mask) - Size is Nfft x Nsym
    X_data_mask = true(Nfft, Nsym);
    
    % Rule A: Exclude all dead carriers (ROWS/Carriers).
    X_data_mask(dead_carriers, :) = false;
    
    % Rule B: Exclude pilot carriers ONLY where pilots are ON (using the pilot mask).
    X_data_mask(X_pilot_mask) = false;
    
    % --- 3. DATA GENERATION AND INSERTION ---
    
    num_data_symbols_needed = sum(X_data_mask(:));
    bitsPerSym = log2(M);
    numBitsTot = num_data_symbols_needed * bitsPerSym;
    
    % Generate random bits and QAM map, sized exactly to fill the mask.
    tx_bits = randi([0 1], numBitsTot, 1);
    tx_idx  = bi2de(reshape(tx_bits, bitsPerSym, []).', 'left-msb');
    tx_sym  = qammod(tx_idx, M, 'UnitAveragePower', true); 
    
    % Assign the flattened stream of data symbols into the TRUE positions of X.
    X(X_data_mask) = tx_sym;

    % --- 4. FINAL CLEAN UP AND TRANSMISSION ---
    
    % Clear dead carriers (set ROWS to zero) - Redundant but good check
    X(dead_carriers, :) = 0;
    Xf = X;

    % IFFT along dimension 1 (ROWS/Carriers)
    Xt = ifft(X, Nfft, 1); 
    
    % CP is the last Ncp ROWS
    cp_rows = (Nfft - Ncp + 1):Nfft;
    
    % Concatenate CP (Vertical Concatenation)
    Xt_cp = [Xt(cp_rows, :); Xt]; 
    
    % Flatten (Column-Major order, which is Symbol-by-Symbol)
    tx = reshape(Xt_cp, 1, numel(Xt_cp));
    
end

function [Yf] = build_OFDM_rx_core(rx_serial, Nfft, Ncp, Nsym)
%BUILD_OFDM_RX_CORE Performs CP removal and FFT on the received serial signal.
%
%   Yf: The full received frequency-domain matrix (Nfft x Nsym).

    % --- CP Removal and FFT ---
    samples_per_symbol = Nfft + Ncp;
    
    % 1. Reshape: Flattened signal to (Nfft+Ncp) rows x Nsym columns (Reverse of Tx)
    Y_cp = reshape(rx_serial, samples_per_symbol, Nsym); 
    
    % 2. CP Removal: Remove the first Ncp ROWS
    Y_no_cp = Y_cp(Ncp + 1 : end, :);
    
    % 3. FFT: Along Dimension 1 (ROWS/Carriers)
    Yf = fft(Y_no_cp, Nfft, 1); 
    
end

function [Y_eq, H_eq] = equalize_ofdm_data(Yf, X_data_mask, X_pilot_mask, Nfft, pilot_carriers, dead_carriers, live_carriers, pilot_sym, Ncirc_permute)
% EQUALIZE_OFDM_DATA implements a One-Tap Equalizer with LS Estimation and Phase Correction.
%
%   MODE 1 (LS Estimation) is implemented here, which assumes the channel is
%   to correct the absolute rotation and scaling errors common in LS.

    [~, Nsym] = size(Yf); 
    Npilots = length(pilot_carriers);
    
    % --- 0. PRE-CALCULATE CONSTANTS (Pilot Reconstruction) ---
    P_base = pilot_sym;
    P_inv = -pilot_sym; 
    pilot_frequency_pattern = repmat([P_base, P_inv], 1, ceil(Npilots/2));
    pilot_frequency_pattern = pilot_frequency_pattern(1:Npilots); 
    X_pilots_tx_reconstructed = zeros(Nfft, Nsym);
    
    pilot_symbol_indices = find(any(X_pilot_mask, 1));
    for m = pilot_symbol_indices
        if mod(m, 2) == 1
            X_pilots_column = pilot_frequency_pattern.'; 
        else
            X_pilots_column = circshift(pilot_frequency_pattern, Ncirc_permute).'; % Transpose for column assignment
        end
        X_pilots_tx_reconstructed(pilot_carriers, m) = X_pilots_column;
    end
    
    % New equalization
    H_eq = zeros(Nfft, Nsym);

    H_eq = (Yf.*X_pilot_mask) ./ X_pilots_tx_reconstructed;

    H_eq (H_eq ==0) = NaN;
    H_eq = fillmissing(H_eq, 'linear', 1);
    H_eq = fillmissing(H_eq, 'linear', 2);

    Yf(dead_carriers, :) = 0;
    Y_symbol_equalized = Yf ./ H_eq;

    Y_eq = Y_symbol_equalized(X_data_mask);
    H_eq = H_eq(live_carriers, :);
end

function [Htrue] = genie_channel(Yf, X, live_carriers)
    Htrue = Yf(live_carriers, :) ./ X(live_carriers, :);
end

function rx_serial = apply_fading_channel(tx_cp_serial, fs, fD, tau_rms, SNR_dB, use_AWGN)
%APPLY_FADING_CHANNEL Simulates a Rayleigh fading channel with AWGN.
%
%   rx_serial = APPLY_FADING_CHANNEL(...) models a time-varying,
%   frequency-selective channel based on Jakes model and adds noise.
%
%   Inputs:
%     tx_cp_serial: Transmitted serial signal with CP included.
%     Nfft: FFT size.
%     Ncp: CP size.
%     Nsym: Number of OFDM symbols.
%     fs: Sampling frequency (Hz).
%     fD: Maximum Doppler Spread (Hz).
%     tau_rms: RMS Delay Spread (seconds).
%     SNR_dB: Signal-to-Noise Ratio (dB).


    Ts = 1 / fs; 
    T_max = 5 * tau_rms; 
    
    % Define the discrete delays (spaced by the sampling time Ts)
    delays = 0 : Ts : T_max;
    
    % Optional: Limit the number of taps if T_max is very large
    if length(delays) > 20
        delays = delays(1:20); % Use only the first 20 taps for complexity management
    end

    % Set the power for each tap:
    gains_linear = exp(-delays / tau_rms);
    
    % Normalize the gains so the total power is 1 (0 dB)
    gains_norm = gains_linear / sum(gains_linear);
    

    % --- 2. Configure the Channel Object ---
    
    % Use comm.RayleighChannel for realistic fading that incorporates Doppler
    channel = comm.RayleighChannel;
    
    channel.SampleRate = fs;
    channel.PathDelays = delays;
    channel.AveragePathGains = 10*log10(gains_norm); % Convert normalized linear gains back to dB
    channel.MaximumDopplerShift = fD; % Incorporates the user's velocity
    channel.Visualization = 'Off';
    
    % --- 3. Apply the Channel Fading ---
    
    % The channel model expects the signal as a column vector.
    tx_cp_col = tx_cp_serial.'; 
    
    % Apply fading (convolution with the time-varying channel impulse response)
    faded_signal = channel(tx_cp_col);
    
    % --- 4. Add Additive White Gaussian Noise (AWGN) ---
    
    % The 'awgn' function adds noise based on the signal power and the required SNR.
    if(use_AWGN)
        rx_serial_col = awgn(faded_signal, SNR_dB, 'measured');
        rx_serial = rx_serial_col.'; 
    else
        rx_serial = faded_signal;
    end


end


function [BER] = calculate_BER(Y_eq, tx_sym_original, M)
% CALCULATE_BER computes the Bit Error Rate (BER) by comparing transmitted and received bits.
%   Y_eq: Stream of equalized received symbols.
%   tx_sym_original: Stream of original transmitted data symbols.
%   M: QAM order (e.g., 16).

    bits_per_symbol = log2(M);
    
    % 1. Symbol De-mapping (Nearest Neighbor Estimation)
    rx_idx = qamdemod(Y_eq, M, 'UnitAveragePower', true);
    tx_idx_original = qamdemod(tx_sym_original, M, 'UnitAveragePower', true);
    
    % 2. Convert Indices to Bits
    tx_bits_original = de2bi(tx_idx_original, bits_per_symbol, 'left-msb');
    tx_bits_original = tx_bits_original(:);
    rx_bits_recovered = de2bi(rx_idx, bits_per_symbol, 'left-msb');
    rx_bits_recovered = rx_bits_recovered(:);
    
    % 3. Calculate BER
    number_of_bit_errors = sum(tx_bits_original ~= rx_bits_recovered);
    total_transmitted_bits = length(tx_bits_original);
    
    BER = number_of_bit_errors / total_transmitted_bits;
end

function [Goodput_bits_per_sample, total_samples_sent] = calculate_Goodput(tx, BER, M, Nfft, Ncp)
% CALCULATE_GOODPUT computes the effective Goodput in bits per total complex sample.
%   tx: The full serial transmitted signal (used to find total samples sent).
%   BER: The calculated Bit Error Rate.
%   M: QAM order.

    bits_per_symbol = log2(M);
    
    % Total number of bits transmitted (data symbols * bits/symbol)
    % This is equivalent to total_transmitted_bits * (1 - BER)
    total_samples_sent = length(tx);
    
    % Total number of data symbols (derived from the total samples sent and CP overhead)
    % Since BER is available, we calculate the Correctly Received Bits:
    total_bits_sent = (total_samples_sent / (1 + (Ncp/Nfft))) * bits_per_symbol;
    
    % Correctly received bits = Total bits sent * (1 - BER)
    correctly_received_bits = total_bits_sent * (1 - BER);
    
    % Goodput = (Correctly Received Bits) / (Total Samples Sent)
    Goodput_bits_per_sample = correctly_received_bits / total_samples_sent;
end

function array_diff = array_set_difference(array1, array2)
%ARRAY_SET_DIFFERENCE returns the entries in array1 that do not appear in array2.
%
%   array1: The primary array from which entries will be removed.
%   array2: The array containing entries to be excluded.

    % 1. Check for membership: Determine which elements of array1 are also present in array2.
    % ismember returns a logical array (e.g., [0 1 0 1 0]) the same size as array1.
    is_present = ismember(array1, array2);

    % 2. Invert the logical array: Find elements NOT present in array2.
    is_absent = ~is_present;

    % 3. Use logical indexing: Extract elements from array1 where the mask is TRUE.
    array_diff = array1(is_absent);
end

function [tx] = build_OFDM_impulse(Nfft, Nsym, Ncp)
    
    % X is now (Nfft x Nsym) -> (Carriers x Symbols)
    X = ones(Nfft, Nsym); 
    
    % IFFT along dimension 1 (ROWS/Carriers)
    Xt = ifft(X, Nfft, 1); 
    
    % CP is the last Ncp ROWS
    cp_rows = (Nfft - Ncp + 1):Nfft;
    
    % Concatenate CP (Vertical Concatenation)
    Xt_cp = [Xt(cp_rows, :); Xt]; 
    
    % Flatten (Column-Major order, which is Symbol-by-Symbol)
    tx = reshape(Xt_cp, 1, numel(Xt_cp));
    
end

function [SER, BER, Goodput_bps, H_error, H_mag] = calculate_performance_metrics(Y_eq, Xf, X_data_mask, Hf_true, Hf_est, tx, M, Nfft, Ncp)
% CALCULATE_PERFORMANCE_METRICS computes communication and channel estimation metrics.
%
%   Inputs:
%     Y_eq: Equalized stream of received data symbols.
%     tx_sym_original: Original stream of transmitted data symbols.
%     Hf_true: True Channel Frequency Response matrix (H_true).
%     Hf_est: Estimated Channel Frequency Response matrix (H_eq).
%     tx: Full serial transmitted signal (for Goodput calculation).
%     M: QAM modulation order.
%     Nfft, Ncp: System parameters needed for Goodput.
%
%   Outputs: SER, BER, Goodput_bps, H_error (TSE), H_mag (Total Power).

    % --- 1. Symbol Error Rate (SER) Calculation ---
    
    tx_sym_original = Xf(X_data_mask);
    % De-map equalized symbols and original symbols to indices
    rx_idx = qamdemod(Y_eq, M, 'UnitAveragePower', true);
    tx_idx_original = qamdemod(tx_sym_original, M, 'UnitAveragePower', true);
    
    % Calculate symbol errors
    number_of_symbol_errors = sum(tx_idx_original ~= rx_idx);
    total_data_symbols = length(tx_sym_original);
    SER = number_of_symbol_errors / total_data_symbols;
    
    % --- 2. Bit Error Rate (BER) and Goodput ---
    
    % Assumes calculate_BER and calculate_Goodput helpers are defined elsewhere.
    BER = calculate_BER(Y_eq, tx_sym_original, M);
    [Goodput_bps, ~] = calculate_Goodput(tx, BER, M, Nfft, Ncp); 
    
    % --- 3. Channel Estimation Error Metrics (NMSE Components) ---
    
    % Calculate the Total Squared Error (Error Power, Numerator for NMSE)
    % This measures the magnitude of the difference between the true and estimated channel.
    H_error = sum(abs(Hf_true - Hf_est).^2, 'all');
    
    % Calculate the Total Channel Power (Denominator for NMSE)
    % This measures the magnitude of the true channel response.
    H_mag = sum(abs(Hf_true).^2, 'all');

end